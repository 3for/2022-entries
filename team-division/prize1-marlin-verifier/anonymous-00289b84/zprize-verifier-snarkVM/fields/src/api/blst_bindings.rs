// Copyright (C) 2019-2022 Aleo Systems Inc.
// This file is part of the snarkVM library.

// The snarkVM library is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// The snarkVM library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with the snarkVM library. If not, see <https://www.gnu.org/licenses/>.
/* automatically generated by rust-bindgen 0.60.1 */

pub const LIMB_T_BITS: u32 = 64;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>(), 32usize, concat!("Size of: ", stringify!(max_align_t)));
    assert_eq!(::std::mem::align_of::<max_align_t>(), 16usize, concat!("Alignment of ", stringify!(max_align_t)));
    fn test_field___clang_max_align_nonce1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(max_align_t), "::", stringify!(__clang_max_align_nonce1))
        );
    }
    test_field___clang_max_align_nonce1();
    fn test_field___clang_max_align_nonce2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<max_align_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize
            },
            16usize,
            concat!("Offset of field: ", stringify!(max_align_t), "::", stringify!(__clang_max_align_nonce2))
        );
    }
    test_field___clang_max_align_nonce2();
}
pub type limb_t = ::std::os::raw::c_ulonglong;
pub type vec256 = [limb_t; 4usize];
pub type vec512 = [limb_t; 8usize];
pub type vec384 = [limb_t; 6usize];
pub type vec768 = [limb_t; 12usize];
pub type vec384x = [vec384; 2usize];
pub type bool_t = limb_t;
extern "C" {
    pub static BLS12_377_Rx: vec384;
}
extern "C" {
    pub static BLS12_377_RR: vec384;
}
pub const p0: limb_t = 9586122913090633727;
extern "C" {
    pub static BLS12_377_P: vec384;
}
extern "C" {
    pub fn blst_fp_mul(ret: *mut limb_t, a: *const limb_t, b: *const limb_t, p: *const limb_t, p0: limb_t);
}
extern "C" {
    pub fn blst_fp_sqr(ret: *mut limb_t, a: *const limb_t, p: *const limb_t, p0: limb_t);
}
extern "C" {
    pub fn blst_fp_eucl_inverse(ret: *mut limb_t, a: *const limb_t, p: *const limb_t, p0: limb_t);
}
